(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{435:function(t,v,_){"use strict";_.r(v);var s=_(0),a=Object(s.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("介绍")]),t._v(" "),v("p",[t._v("汇编的使用,I.MX6ULL和STM32的异同")])]),t._v(" "),v("h1",{attrs:{id:"i-mx6ull学习day1"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#i-mx6ull学习day1"}},[t._v("#")]),t._v(" I.MX6Ull学习day1")]),t._v(" "),v("h2",{attrs:{id:"gun汇编语法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#gun汇编语法"}},[t._v("#")]),t._v(" GUN汇编语法")]),t._v(" "),v("p",[t._v("开发i.mx6ull时首先要使用汇编语言初始化一些SOC外设,DDR(i.mx6u不需要),设置sp指针(一般指向DDR),设置C语言运行环境.")]),t._v(" "),v("h3",{attrs:{id:"gun汇编语法适用于所有的架构-并不是arm专有的-gun汇编由一系列语句组成-每行一条语句-每条语句有三个可选部分"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#gun汇编语法适用于所有的架构-并不是arm专有的-gun汇编由一系列语句组成-每行一条语句-每条语句有三个可选部分"}},[t._v("#")]),t._v(" GUN汇编语法适用于所有的架构，并不是arm专有的.GUN汇编由一系列语句组成,每行一条语句,每条语句有三个可选部分.")]),t._v(" "),v("div",{staticClass:"language-assembly line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("label:instruction@comment\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br")])]),v("ul",[v("li",[v("p",[v("strong",[t._v("label")]),t._v(":标号")]),t._v(" "),v("p",[t._v("表示地址位置(非必须)，通过这个标号可以得到指令或数据地址.")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("instruction")]),t._v(":指令")]),t._v(" "),v("p",[t._v("汇编指令或伪指令(必须).")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("@")]),t._v(":注释符")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("comment")]),t._v(":注释内容")])])]),t._v(" "),v("h3",{attrs:{id:"伪操作指令"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#伪操作指令"}},[t._v("#")]),t._v(" 伪操作指令")]),t._v(" "),v("ol",[v("li",[v("p",[v("code",[t._v(".section")]),t._v(":用户可以使用该命令来定义一个段.")]),t._v(" "),v("p",[t._v("汇编系统预定义了一些段名:")]),t._v(" "),v("ul",[v("li",[v("code",[t._v(".text")]),t._v("表示代码段.")]),t._v(" "),v("li",[v("code",[t._v(".data")]),t._v("初始化的数据段.")]),t._v(" "),v("li",[v("code",[t._v(".bss")]),t._v("未初始化的数据段.")]),t._v(" "),v("li",[v("code",[t._v(".rodata")]),t._v("只读数据段.")])])]),t._v(" "),v("li",[v("p",[v("code",[t._v(".global")]),t._v(":定义全局标号.比如"),v("code",[t._v(".global _start")]),t._v(".")])]),t._v(" "),v("li",[v("p",[v("code",[t._v(".byte")]),t._v(":定义单字节数据.比如"),v("code",[t._v(".byte 0x12")]),t._v("。")])]),t._v(" "),v("li",[v("p",[v("code",[t._v(".short")]),t._v(":定义双字节数据.比如"),v("code",[t._v(".short 0x1234")]),t._v("。")])]),t._v(" "),v("li",[v("p",[v("code",[t._v(".long")]),t._v(":定义一个 4 字节数据.比如"),v("code",[t._v(".long 0x12345678")]),t._v(".")])]),t._v(" "),v("li",[v("p",[v("code",[t._v(".equ")]),t._v(":赋值语句.格式为"),v("code",[t._v(".equ 变量名,表达式")]),t._v(",比如"),v("code",[t._v(".equ num, 0x12")]),t._v("，表示"),v("code",[t._v("num=0x12")])])]),t._v(" "),v("li",[v("p",[v("code",[t._v(".align")]),t._v(":数据字节对齐.比如"),v("code",[t._v(".align 4")]),t._v("表示4字节对齐。")])]),t._v(" "),v("li",[v("p",[v("code",[t._v(".end")]),t._v("表示源文件结束。")])])]),t._v(" "),v("h3",{attrs:{id:"程序入口"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#程序入口"}},[t._v("#")]),t._v(" 程序入口")]),t._v(" "),v("p",[t._v("汇编程序的默认入口标号是"),v("code",[t._v("_start")]),t._v("，也可在链接脚本中使用"),v("code",[t._v("ENTRY")]),t._v("来指明其入口点.")]),t._v(" "),v("div",{staticClass:"language-assembly line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v(".global _start \n\n_start:\nldr r0, =0x12 @r0=0x12\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br"),v("span",{staticClass:"line-number"},[t._v("2")]),v("br"),v("span",{staticClass:"line-number"},[t._v("3")]),v("br"),v("span",{staticClass:"line-number"},[t._v("4")]),v("br")])]),v("h3",{attrs:{id:"gun汇编函数"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#gun汇编函数"}},[t._v("#")]),t._v(" GUN汇编函数")]),t._v(" "),v("p",[t._v("函数格式如下")]),t._v(" "),v("div",{staticClass:"language-assembly line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("函数名:\n\t函数体\n\t返回语句(非必须)\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br"),v("span",{staticClass:"line-number"},[t._v("2")]),v("br"),v("span",{staticClass:"line-number"},[t._v("3")]),v("br")])]),v("h3",{attrs:{id:"常用汇编指令"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#常用汇编指令"}},[t._v("#")]),t._v(" 常用汇编指令")]),t._v(" "),v("p",[v("strong",[t._v("待补充")])]),t._v(" "),v("h3",{attrs:{id:"处理器内部数据传输汇编指令"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#处理器内部数据传输汇编指令"}},[t._v("#")]),t._v(" 处理器内部数据传输汇编指令")]),t._v(" "),v("p",[t._v("处理器做的最多事情就是来回的传递数据，常见的操作有：")]),t._v(" "),v("ul",[v("li",[t._v("将数据从一个寄存器传递到另外一个寄存器。")]),t._v(" "),v("li",[t._v("将数据从一个寄存器传递到特殊寄存器，如 CPSR 和 SPSR 寄存器。")]),t._v(" "),v("li",[t._v("将立即数传递到寄存器。")])]),t._v(" "),v("p",[t._v("数据传输常用的指令有以下三个")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("指令")]),t._v(" "),v("th",[t._v("目的")]),t._v(" "),v("th",[t._v("源")]),t._v(" "),v("th",[t._v("描述")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("MOV")]),t._v(" "),v("td",[t._v("R0")]),t._v(" "),v("td",[t._v("R1")]),t._v(" "),v("td",[t._v("将R1里面的数据复制到R0中")])]),t._v(" "),v("tr",[v("td",[t._v("MRS")]),t._v(" "),v("td",[t._v("R0")]),t._v(" "),v("td",[t._v("CPSR")]),t._v(" "),v("td",[t._v("将特殊寄存器CPSR里面的数据复制到R0中")])]),t._v(" "),v("tr",[v("td",[t._v("MSR")]),t._v(" "),v("td",[t._v("CPSR")]),t._v(" "),v("td",[t._v("R1")]),t._v(" "),v("td",[t._v("将R1里面的数据复制到特殊寄存器CPSR里中")])])])]),t._v(" "),v("ol",[v("li",[v("p",[v("strong",[t._v("MOV")]),t._v("指令")]),t._v(" "),v("p",[t._v("MOV指令用于将数据从一个寄存器拷贝到另外一个寄存器，或者将一个立即数传递到寄存器里面.")]),t._v(" "),v("div",{staticClass:"language-assembly line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("MOV R0, R1\t\t@将寄存器R1中的数据传递给R0\nMOV R0, #0X12 \t@将立即数0X12传递给R0寄存器\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br"),v("span",{staticClass:"line-number"},[t._v("2")]),v("br")])])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("MRS")]),t._v("指令")]),t._v(" "),v("p",[t._v("MRS指令用于将特殊寄存器(如CPSR和SPSR)中的数据传递给通用寄存器，要读取特殊寄存器的数据只能使用MRS指令.")]),t._v(" "),v("div",{staticClass:"language-assembly line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("MRS R0, CPSR\t@将特殊寄存器CPSR里面的数据传递给R0\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br")])])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("MSR")]),t._v("指令")]),t._v(" "),v("p",[t._v("MSR指令和MRS刚好相反，MSR指令用来将普通寄存器的数据传递给特殊寄存器，也就是写特殊寄存器，写特殊寄存器只能使用MSR.")]),t._v(" "),v("div",{staticClass:"language-assembly line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("MSR CPSR, R0\t@将R0中的数据复制到CPSR中\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br")])])])]),t._v(" "),v("h3",{attrs:{id:"存储器-访问指令"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#存储器-访问指令"}},[t._v("#")]),t._v(" 存储器 访问指令")]),t._v(" "),v("p",[t._v("ARM不能直接访问存储器(包含RAM)中的数据.I.MX6ULL的寄存器就是RAM类型的,在使用汇编来配置I.MX6ULL寄存器的时候要借助存储器访问指令.先将要配置的值写入Rx(x=0~12)寄存器中,再借助存储器访问指令将Rx中的数据写入到I.MX6ULL寄存器中(读取过程与之相反).")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("常用的存储器访问指令")]),t._v(" "),v("th",[t._v("描述")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("LDR Rd,[Rn,#offset]")]),t._v(" "),v("td",[t._v("从存储器Rn+offset的位置读取数据存放到Rd中")])]),t._v(" "),v("tr",[v("td",[t._v("STR Rd,[Rn,#offset]")]),t._v(" "),v("td",[t._v("将Rd中的数据写入到存储器中的Rn+offset位置")])])])]),t._v(" "),v("ol",[v("li",[v("p",[v("strong",[t._v("LDR")]),t._v("指令")]),t._v(" "),v("p",[t._v("LDR 主要用于从存储加载数据到寄存器Rx中，LDR也可以将一个立即数加载到寄存器Rx")]),t._v(" "),v("p",[t._v('中(加载立即数的时候要使用"=")。在嵌入式开发中，LDR最常用的就是读取CPU的寄存器值.')]),t._v(" "),v("div",{staticClass:"language-assembly line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("LDR R0, =0X0209C004\t\t@将寄存器地址0X0209C004加载到R0中\nLDR R1, [R0]\t\t\t@读取地址0X0209C004中的数据到R1寄存器中\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br"),v("span",{staticClass:"line-number"},[t._v("2")]),v("br")])])]),t._v(" "),v("li",[v("p",[t._v("STR指令")]),t._v(" "),v("p",[t._v("STR 就是将数据写入到存储器中.")]),t._v(" "),v("div",{staticClass:"language-assembly line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("LDR R0, =0X0209C004\t\t@将寄存器地址0X0209C004加载到R0中\nLDR R1, =0X20000002\t\t@R1保存要写入到寄存器的值\nSTR R1, [R0]\t\t\t@将R1中的值写入到R0中所保存的地址中\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br"),v("span",{staticClass:"line-number"},[t._v("2")]),v("br"),v("span",{staticClass:"line-number"},[t._v("3")]),v("br")])])])]),t._v(" "),v("p",[t._v("LDR和STR都是按照字(32位数据)进行读取和写入的，可在LDR指令后面加上B或H可以对字节、半字进行操作，比如LDRB和STRB指令按字节操作，LDRH和STRH指令按半字操作.")]),t._v(" "),v("h3",{attrs:{id:"压栈和出栈指令"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#压栈和出栈指令"}},[t._v("#")]),t._v(" 压栈和出栈指令")]),t._v(" "),v("p",[t._v("在A函数中调用B函数，当B函数执行完以后再回到A函数继续执行。在跳到B函数之前将当前处理器状态保存起来(就是保存R0~R15这些寄存器值)，当B函数执行完成后将保存的寄存器值恢复R0~R15,即可跳回A函数接着正常运行。保存R0~R15寄存器的操作就叫做现场保护，恢复R0~R15寄存器的操作就叫做恢复现场。现场保护需要进行压栈(入栈)操作，恢复现场要进行出栈操作。压栈指令为PUSH，出栈指令为POP，PUSH和POP是一种多存储和多加载指令，可以一次操作多个寄存器数据，利用当前的栈指针SP来生成地址.")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("指令")]),t._v(" "),v("th",[t._v("描述")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("PUSH "),v("reg",{attrs:{list:""}})],1),t._v(" "),v("td",[t._v("将寄存器列表存入栈中")])]),t._v(" "),v("tr",[v("td",[t._v("POP "),v("reg",{attrs:{list:""}})],1),t._v(" "),v("td",[t._v("从栈中恢复寄存器列表")])])])]),t._v(" "),v("p",[t._v("**e.g.**将R0~R3和R12这五个寄存器压栈,当前的SP指针指向0X80000000(处理器的堆栈向下增长).")]),t._v(" "),v("div",{staticClass:"language-assembly line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("PUSH {R0~R3,R12}\t@将R0~R3和R12压栈\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br")])]),v("p",[v("img",{attrs:{src:"https://778b-1317013106.cos.ap-nanjing.myqcloud.com/img/202303162218522.png",alt:"image-20230316221813490"}})]),t._v(" "),v("p",[t._v("对R0~R3,R12进行压栈以后，SP指向了0X7FFFFFEC.")]),t._v(" "),v("p",[t._v("现在再对LR进行压栈")]),t._v(" "),v("div",{staticClass:"language-assembly line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("PUSH {LR}\t@将LR进行压栈\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br")])]),v("p",[v("img",{attrs:{src:"https://778b-1317013106.cos.ap-nanjing.myqcloud.com/img/202303162217162.png",alt:"image-20230316221708120"}})]),t._v(" "),v("p",[t._v("再次压栈结束后SP指向了0X7FFFFFE8.")]),t._v(" "),v("p",[t._v("进行出栈操作")]),t._v(" "),v("div",{staticClass:"language-assembly line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("POP {LR}\t\t\t@先恢复LR\nPOP {R0~R3,R12}\t\t@再恢复R0~R3,R12\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br"),v("span",{staticClass:"line-number"},[t._v("2")]),v("br")])]),v("p",[t._v("ps:"),v("code",[t._v("PUSH")]),t._v("和"),v("code",[t._v("POP")]),t._v("可用"),v("code",[t._v("STMFD SP!")]),t._v("和"),v("code",[t._v("LDMFD SP!")]),t._v("代替.")]),t._v(" "),v("h3",{attrs:{id:"跳转指令"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#跳转指令"}},[t._v("#")]),t._v(" 跳转指令")]),t._v(" "),v("p",[t._v("有两种方式可以完成跳转操作:1,直接向PC寄存器写数据.2,使用跳转指令B,BL,BX等.")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("指令")]),t._v(" "),v("th",[t._v("描述")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("B "),v("label")]),t._v(" "),v("td",[t._v("跳转到label，如果跳转范围超过了+/-2KB,可以指定B.W "),v("label",[t._v("使用32位版本的跳转指令，得到较大范围的跳转")])])]),t._v(" "),v("tr",[v("td",[t._v("BX "),v("Rm")],1),t._v(" "),v("td",[t._v("间接跳转，跳转到存放于Rm中的地址处，并且切换指令集")])]),t._v(" "),v("tr",[v("td",[t._v("BL "),v("lable")],1),t._v(" "),v("td",[t._v("跳转到标号地址，并将返回地址保存在LR中")])]),t._v(" "),v("tr",[v("td",[t._v("BLX "),v("Rm")],1),t._v(" "),v("td",[t._v("结合BX和BL的特点，跳转到Rm指定的地址，并将返回地址保存在LR中，切换指令集")])])])]),t._v(" "),v("ol",[v("li",[v("p",[v("strong",[t._v("B")]),t._v("指令")]),t._v(" "),v("p",[t._v("B是最简单的跳转指令，B指令会将PC寄存器的值设置为跳转目标地址， 一旦执行B指令，ARM处理器就会立即跳转到指定的目标地址。如果要调用的函数不会再返回到原来的执行处，那就可以用B指令.")]),t._v(" "),v("div",{staticClass:"language-assembly line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("_start:\n\nldr sp, =0X80200000\t@设置栈指针\nb main \t\t\t   @跳转到 main 函数\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br"),v("span",{staticClass:"line-number"},[t._v("2")]),v("br"),v("span",{staticClass:"line-number"},[t._v("3")]),v("br"),v("span",{staticClass:"line-number"},[t._v("4")]),v("br")])]),v("p",[t._v("ps:这里只是初始化了SP指针，有些处理器还需要做DDR等其他的初始化.跳到C文件后无需回到汇编.")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("BL")]),t._v("指令")]),t._v(" "),v("p",[t._v("BL指令相比B指令，在跳转前会在寄存器LR(R14)中保存当前PC寄存器值，可以通过将LR寄存器中的值重新加载到PC中来继续从跳转之前的代码处运行，这是子程序调用一个基本但常用的手段。Cortex-A处理器的irq中断服务函数都是汇编写的，用汇编实现了现场的保护和恢复、获取中断号等。但具体的中断处理过程都是C函数，所以就会存在汇编中调用C函数的问题。而且当C语言版本的中断处理函数执行完成以后是需要返回到irq汇编中断服务函数，因为还要处理其他的工作，一般是恢复现场。这个时候就不能直接使用B指令了，因为B指令一旦跳转就再也不会回来了，这个时候要使用BL指令.")]),t._v(" "),v("div",{staticClass:"language-assembly line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("push {r0, r1}\t\t@保存 r0,r1\ncps #0x13 \t\t\t@进入 SVC 模式，允许其他中断再次进去\n\nbl system_irqhandler @加载 C 语言中断处理函数到 r2 寄存器中\n\ncps #0x12 \t\t\t@进入 IRQ 模式\npop {r0, r1} \nstr r0, [r1, #0X10]  @中断执行完成，写 EOIR\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br"),v("span",{staticClass:"line-number"},[t._v("2")]),v("br"),v("span",{staticClass:"line-number"},[t._v("3")]),v("br"),v("span",{staticClass:"line-number"},[t._v("4")]),v("br"),v("span",{staticClass:"line-number"},[t._v("5")]),v("br"),v("span",{staticClass:"line-number"},[t._v("6")]),v("br"),v("span",{staticClass:"line-number"},[t._v("7")]),v("br"),v("span",{staticClass:"line-number"},[t._v("8")]),v("br")])]),v("p",[t._v("ps:执行C语言版的中断处理函数"),v("code",[t._v("system_irqhandler")]),t._v("，处理完成以后返回继续执行下面的程序.")])])]),t._v(" "),v("h3",{attrs:{id:"算数运算指令"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#算数运算指令"}},[t._v("#")]),t._v(" 算数运算指令")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("指令")]),t._v(" "),v("th",[t._v("计算公式")]),t._v(" "),v("th",[t._v("备注")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("ADD Rd, Rn, Rm")]),t._v(" "),v("td",[t._v("Rd = Rn + Rm")]),t._v(" "),v("td",[t._v("加法运算")])]),t._v(" "),v("tr",[v("td",[t._v("ADD Rd, Rn, #immed")]),t._v(" "),v("td",[t._v("Rd = Rn + #immed")]),t._v(" "),v("td",[t._v("加法运算")])]),t._v(" "),v("tr",[v("td",[t._v("ADC Rd, Rn, Rm")]),t._v(" "),v("td",[t._v("Rd = Rn + Rm + 进位")]),t._v(" "),v("td",[t._v("带进位的加法运算")])]),t._v(" "),v("tr",[v("td",[t._v("ADC Rd, Rn, #immed")]),t._v(" "),v("td",[t._v("Rd = Rn + #immed +进位")]),t._v(" "),v("td",[t._v("带进位的加法运算")])]),t._v(" "),v("tr",[v("td",[t._v("SUB Rd, Rn, Rm")]),t._v(" "),v("td",[t._v("Rd = Rn - Rm")]),t._v(" "),v("td",[t._v("减法")])]),t._v(" "),v("tr",[v("td",[t._v("SUB Rd, #immed")]),t._v(" "),v("td",[t._v("Rd = Rd - #immed")]),t._v(" "),v("td",[t._v("减法")])]),t._v(" "),v("tr",[v("td",[t._v("SUB Rd, Rn, #immed")]),t._v(" "),v("td",[t._v("Rd = Rn - #immed")]),t._v(" "),v("td",[t._v("减法")])]),t._v(" "),v("tr",[v("td",[t._v("SBC Rd, Rn, #immed")]),t._v(" "),v("td",[t._v("Rd = Rn - #immed - 借位")]),t._v(" "),v("td",[t._v("带借位的减法")])]),t._v(" "),v("tr",[v("td",[t._v("SBC Rd, Rn ,Rm")]),t._v(" "),v("td",[t._v("Rd = Rn - Rm - 借位")]),t._v(" "),v("td",[t._v("带借位的减法")])]),t._v(" "),v("tr",[v("td",[t._v("MUL Rd, Rn, Rm")]),t._v(" "),v("td",[t._v("Rd = Rn * Rm")]),t._v(" "),v("td",[t._v("乘法(32 位)")])]),t._v(" "),v("tr",[v("td",[t._v("UDIV Rd, Rn, Rm")]),t._v(" "),v("td",[t._v("Rd = Rn / Rm")]),t._v(" "),v("td",[t._v("无符号除法")])]),t._v(" "),v("tr",[v("td",[t._v("SDIV Rd, Rn, Rm")]),t._v(" "),v("td",[t._v("Rd = Rn / Rm")]),t._v(" "),v("td",[t._v("有符号除法")])])])]),t._v(" "),v("p",[t._v("ps:常用加减指令")]),t._v(" "),v("h3",{attrs:{id:"逻辑运算指令"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#逻辑运算指令"}},[t._v("#")]),t._v(" 逻辑运算指令")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("指令")]),t._v(" "),v("th",[t._v("计算公式")]),t._v(" "),v("th",[t._v("备注")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("AND Rd, Rn")]),t._v(" "),v("td",[t._v("Rd = Rd & Rn")]),t._v(" "),v("td",[t._v("按位与")])]),t._v(" "),v("tr",[v("td",[t._v("AND Rd, Rn, #immed")]),t._v(" "),v("td",[t._v("Rd = Rn & #immed")]),t._v(" "),v("td",[t._v("按位与")])]),t._v(" "),v("tr",[v("td",[t._v("AND Rd, Rn, Rm")]),t._v(" "),v("td",[t._v("Rd = Rn & Rm")]),t._v(" "),v("td",[t._v("按位与")])]),t._v(" "),v("tr",[v("td",[t._v("ORR Rd, Rn")]),t._v(" "),v("td",[t._v("Rd = Rd | Rn")]),t._v(" "),v("td",[t._v("按位或")])]),t._v(" "),v("tr",[v("td",[t._v("ORR Rd, Rn, #immed")]),t._v(" "),v("td",[t._v("Rd = Rn | #immed")]),t._v(" "),v("td",[t._v("按位或")])]),t._v(" "),v("tr",[v("td",[t._v("ORR Rd, Rn, Rm")]),t._v(" "),v("td",[t._v("Rd = Rn | Rm")]),t._v(" "),v("td",[t._v("按位或")])]),t._v(" "),v("tr",[v("td",[t._v("BIC Rd, Rn")]),t._v(" "),v("td",[t._v("Rd = Rd & (~Rn)")]),t._v(" "),v("td",[t._v("位清除")])]),t._v(" "),v("tr",[v("td",[t._v("BIC Rd, Rn, #immed")]),t._v(" "),v("td",[t._v("Rd = Rn & (~#immed)")]),t._v(" "),v("td",[t._v("位清除")])]),t._v(" "),v("tr",[v("td",[t._v("BIC Rd, Rn , Rm")]),t._v(" "),v("td",[t._v("Rd = Rn & (~Rm)")]),t._v(" "),v("td",[t._v("位清除")])]),t._v(" "),v("tr",[v("td",[t._v("ORN Rd, Rn, #immed")]),t._v(" "),v("td",[t._v("Rd = Rn | (#immed)")]),t._v(" "),v("td",[t._v("按位或非")])]),t._v(" "),v("tr",[v("td",[t._v("ORN Rd, Rn, Rm")]),t._v(" "),v("td",[t._v("Rd = Rn | (Rm)")]),t._v(" "),v("td",[t._v("按位或非")])]),t._v(" "),v("tr",[v("td",[t._v("EOR Rd, Rn")]),t._v(" "),v("td",[t._v("Rd = Rd ^ Rn")]),t._v(" "),v("td",[t._v("按位异或")])]),t._v(" "),v("tr",[v("td",[t._v("EOR Rd, Rn, #immed")]),t._v(" "),v("td",[t._v("Rd = Rn ^ #immed")]),t._v(" "),v("td",[t._v("按位异或")])]),t._v(" "),v("tr",[v("td",[t._v("EOR Rd, Rn, Rm")]),t._v(" "),v("td",[t._v("Rd = Rn ^ Rm")]),t._v(" "),v("td",[t._v("按位异或")])])])]),t._v(" "),v("h2",{attrs:{id:"对比i-mx6ull和stm32初始化gpio"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#对比i-mx6ull和stm32初始化gpio"}},[t._v("#")]),t._v(" 对比i.mx6ull和STM32初始化GPIO")]),t._v(" "),v("h3",{attrs:{id:"stm32"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#stm32"}},[t._v("#")]),t._v(" STM32")]),t._v(" "),v("ol",[v("li",[t._v("使能GPIO时钟.")]),t._v(" "),v("li",[t._v("设置IO的复用:将其复用为GPIO.")]),t._v(" "),v("li",[t._v("配置GPIO的电器属性.")]),t._v(" "),v("li",[t._v("使用GPIO.")])]),t._v(" "),v("h3",{attrs:{id:"i-mx6u"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#i-mx6u"}},[t._v("#")]),t._v(" I.MX6U")]),t._v(" "),v("ol",[v("li",[t._v("使能时钟:CCGR0~CCGR6这七个寄存器控制了所有外设时钟的使能.")]),t._v(" "),v("li",[t._v("IO复用:将寄存器"),v("code",[t._v("IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO03")]),t._v("的bit3~0设置为0101,这时GPIO1_IO03被复用为GPIO.")]),t._v(" "),v("li",[t._v("配置电器属性:寄存器"),v("code",[t._v("IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO03")]),t._v("可以设置压摆率,速度,驱动能力,开漏,上下拉等电器属性")]),t._v(" "),v("li",[t._v("配置GPIO功能:设置输入输出,设置"),v("code",[t._v("GPIO1_GDIR")]),t._v("寄存器bit3为1,将"),v("code",[t._v("GPIO1_IO03")]),t._v("设置为输出.")])])])}),[],!1,null,null,null);v.default=a.exports}}]);